\documentclass{article}
\usepackage{amsmath,amssymb}
\usepackage{proof}
\usepackage{stmaryrd}
\usepackage[legalpaper,margin=1cm]{geometry}
\usepackage[usenames,dvipsnames]{xcolor}

\title{SimFL}


\def\code#1{\textsf{#1}}
\def\codesf#1{\textsf{#1}}
\def\por{\ | \ }
\def\rt{\Rightarrow}
\def\binop{\, \text{\textbullet}\, }
\def\xj#1#2{\langle #1 \ | \ #2 \rangle}
\def\envj#1#2#3{#1 \vdash #2 \rt #3}
\def\noenvj#1#2{#1 \rt #2}
\def\xnf#1#2#3{D,#1 : #2 \rightsquigarrow #3}
\def\sem#1{\llbracket\, #1 \,\rrbracket}
\def\closure#1#2#3{(\textsf{\textbf{closure}} \ #1 \to #2,#3)}
\def\val#1#2#3{(\textsf{\textbf{val}} \ #1 \ {#2} , #3 )}
\def\tsc#1{\textsc{#1}}
\def\matchj#1#2#3{#1 \triangleright #2 : #3}

\begin{document}

\maketitle
\section*{Syntax}

\begin{gather*}
\alpha \in \textsc{TypeVar}\qquad T \in \textsc{TypeCon}\qquad C \in \textsc{DataCon}
\end{gather*}
\begin{align*}
datadef\in \textsc{DataDef} ::= \ & \code{data $T$ $\overline{\alpha}$ = $\delta$ }\overline{\langle\texttt{|}\ \delta\rangle}\\
\delta \in \textsc{ConDef} ::= \ & \code{$C$ $\overline{\tau}$}
\end{align*}

\begin{align*}
e \in \textsc{Expr} ::= \ & x \\
\por & n \\
\por & C \\
\por & \code{[ ]}\\
\por & \code{[}\,e\,\overline{\langle \code{,}\ e\rangle}\,\code{]}\\
\por & e \binop e\\
\por & \texttt{($\binop$)}\\
\por & \code{fun $x$ \texttt{->} $e$}\\
\por & e \ e\\
\por & \code{let $x$ = $e$ in $e$}\\
\por & \code{let rec $f$ $x$ = $e$ }\overline{\langle\code{and rec $f$ $x$ = $e$}\rangle}\code{ in $e$}\\
\por & \code{case $e$ of }\texttt{\char`\{} \ \code{$p$ \texttt{->} $e$}\ \overline{\langle \texttt{;} \, \code{$p$ \texttt{->} $e$}\rangle} \ \texttt{\char`\}}\\
\por & \code{if $e$ then $e$ else $e$}\\
%
d \in \textsc{Decl} ::= \ & \code{$f$ = $e$}\\
\por & \code{rec $f$ $x$ = $e$}\\
\por & \code{data $T$ = }\code{$C$ $\overline{\tau}$ }\overline{\langle\texttt{|} \ C\ \overline{\tau}\rangle}\\
\por & {\color{Bittersweet}\code{rec $f$ $x:\tau$ = $e$}}\\
\por & {\color{Bittersweet}\code{rec $f$ $x$ $\overline{x}$ = $e$}}\\
\por & {\color{Bittersweet}\code{data $T$ $\overline{\alpha}$ = $\delta$ }\overline{\langle\texttt{|}\ \delta\rangle}}\\
%
\binop \in \textsc{BinOp} ::= \ & s\overline{s}
\end{align*}

\begin{align*}
v\in \textsc{Value}::=\ & C \ \overline{v} \\
\por & \closure x e \rho
\end{align*}
\pagebreak

\begin{gather*}
\infer[\tsc{Num}]{\envj \rho n n}{}\qquad
\infer[\tsc{Con}]{\envj \rho C C}{}\qquad
\infer[\tsc{Var}]{\envj \rho x v}{(x,v)\in \rho}\\[12pt]
\infer[\tsc{Fun}]{\envj \rho {\code{fun $x$ \texttt{->} $e$}} {\closure x e \rho}}{}\\[12pt]
\infer[\tsc{App}]{\envj \rho {e_1 \ e_2} v_3}{\envj{\rho}{e_1}{\closure x {e_3} {\sigma}} && \envj \rho {e_2} {v_2} && \envj{\sigma [x\mapsto v_2]}{e_3}{v_3}}\\[12pt]
\infer[\tsc{AppCons}]{\envj{\rho}{e_1\, e_2}{C\ \hat{v},v}}{\envj{\rho}{e_1}{C\ \hat{v}} && \envj{\rho}{e_2}{v}}\\[12pt]
\infer[\tsc{Let}]{\envj \rho {\code{let $x$ = $e_1$ in $e_2$}} {v_2}}{\envj \rho {e_1} {v_1} && \envj {\rho[x\mapsto v_1]} {e_2} {v_2}}\\[12pt]
\infer[\tsc{Case}]{\envj \rho {\code{case $e$ of \{$\overline{\langle p_n \texttt{ -> } e_n\rangle}$\}}} {v_2}}{\envj \rho {e} {v} && v\triangleright p_i : \sigma_i && \envj {\rho,\sigma_i}{e_i}{v_i} && i \leq n}\\[12pt]
\infer[\tsc{BuiltInOp}]{\envj \rho {e_1 \binop e_2} {v_1\llbracket\bullet \rrbracket v_2}}{\envj \rho {e_1} {v_1} && \envj {\rho} {e_2} {v_2} && \textsf{builtin}\, \binop}\qquad
\infer[\tsc{BuiltInFun}]{\envj \rho {\texttt{($\binop$)}} {v}}{\envj \rho {\code{fun a \texttt{->} (fun b \texttt{->} a $\binop$ b)}} {v} && \textsf{builtin}\, \binop}\\[12pt]
\infer[\tsc{BuiltInFun}]{\envj \rho {\texttt{($\binop$)}} {v}}{\envj \rho {\code{fun a \texttt{->} (fun b \texttt{->} a $\binop$ b)}} {v} && \textsf{builtin}\, \binop}\\[12pt]
\end{gather*}

\begin{gather*}
\infer[\tsc{MatchAny}]{\matchj v {\texttt{\_}\,} \varnothing}{}\qquad
\infer[\tsc{MatchVar}]{\matchj v x {\{x\mapsto v\}}}{}\\[12pt]
\infer[\tsc{MatchCons}]{\matchj {C\ \hat{v}} {C\ \hat{p}} \sigma}{\forall i \leq n,\ \, \matchj{v_i}{p_i}{\sigma_i} && \bigcap_{j=1}^n \textsf{free}(\sigma_j)=\varnothing && \sigma = \bigcup_{j=1}^n \sigma_j}	
\end{gather*}




\end{document}